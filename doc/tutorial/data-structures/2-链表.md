# 链表

## 链表的底层存储结构

链表通过“指针”将一组**零散的内存块**串联起来使用。

## 常见的链表结构

### 1. 单链表 （Singly Linked List）

#### 定义

- **结点**：链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的"**结点**"。
- **后继指针**：为了将所有的结点串联起来，每个链表的结点还需要记录链上的下一个结点的地址。这个记录下个结点地址的指针叫做**后继指针 next**。
- **头结点**：链表的第一个结点叫作头结点，用来记录**链表的基地址**。可以用它来遍历得到整条链表。
- **尾结点**：尾结点的指针指向**空地址 NULL**，表示这是链表上的最后一个结点。

<img src="../images/singly-linked-list-definition.png" alt="img" style="zoom:45%;float:left" />

#### 操作

**查找**：链表随机访问第 k 个元素，需要 **O(n)** 的时间复杂度

**插入**：链表在插入一个结点的时候，插入操作本身需要 **O(1)** 的时间复杂度。插入一个结点的时候只需要考虑相邻结点的指针改变。（需要考虑插入位置，头结点，中间位置，尾结点）。

**删除**：链表在删除一个结点的时候，删除操作本身需要 **O(1)** 的时间复杂度。删除一个结点的时候只需要考虑相邻结点的指针改变。（需要考虑删除节点的位置，头结点，中间位置，尾结点）。

<img src="../images/singly-linked-list-operation-insert-delete.png" alt="img" style="zoom:45%;float:left;" />

#### 实现

TODO

### 2. 循环链表（Circular Linked List）

#### 定义

循环链表是一种特殊的单链表。它跟单链表唯一的区别就在尾结点。**循环链表的尾结点指向链表的头结点。**

<img src="../images/circular-linked-list-definition.png" alt="img" style="zoom:45%;float:left;" />

#### 应用场景

**从链尾到链头比较方便**。当要处理的数据具有环形结构特点时，就特别适合采用循环列表。比如约瑟夫问题。

### 3. 双向链表（Doubly Linked List）

#### 定义

双向链表支持两个方向：

- **前驱指针**：每个结点有一个**前驱指针 prev** 指向前面的结点。
- **后继指针**：每个结点有一个**后继指针 next** 指向后面的结点。
- **头结点**：双向链表的第一个结点叫作头结点，用来记录**链表的基地址**。可以用它来遍历得到整条链表。头结点的**前驱指针 prev**指向**空地址 NULL**。
- **尾结点**：尾结点的**后继指针 next** 指向**空地址 NULL**，表示这是双向链表上的最后一个结点。

<img src="../images/doubly-linked-list-definition.png" alt="img" style="zoom:45%;float:left;" />

#### 操作

**查找**：链表随机访问第 k 个元素，需要 **O(n)** 的时间复杂度。**查找指定结点的前驱结点，时间复杂度为 O(1)** 。

- 对于一个**有序链表**，双向链表按值查询的效率要高于单链表。通过记录上次的查询位置，下次查询的时候通过比较可以判断出向前还是向后查找，所以**只需要查找一半的数据**。

**插入**：链表在插入一个结点的时候，插入操作本身需要 **O(1)** 的时间复杂度。插入一个结点的时候只需要考虑相邻结点的指针改变。（需要考虑插入位置，头结点，中间位置，尾结点）。

- **插入到结点中”值等于某个给定值“的结点**：需要从头结点遍历，查询的时间复杂度为 O(n)，插入操作的时间复杂度为 O(1)，总的时间复杂度为 **O(n)**
- **插入给定指针指向的结点**：已经找到了要插入的结点，双链表的插入时间复杂度为 **O(1)**

**删除**：链表在删除一个结点的时候，删除操作本身需要 **O(1)** 的时间复杂度。删除一个结点的时候只需要考虑相邻结点的指针改变。（需要考虑删除节点的位置，头结点，中间位置，尾结点）。

- **删除结点中”值等于某个给定值“的结点**：需要从头结点遍历，查询的时间复杂度为 O(n)，删除操作的时间复杂度为 O(1)，总的时间复杂度为 **O(n)**
- **删除给定指针指向的结点**：已经找到了要删除的结点，双链表的删除时间复杂度为 **O(1)**

#### 实现

TODO

#### 优点和缺点

##### 缺点

双向链表需要额外的两个空间来存储前驱指针和后继指针地址，存储同样多的数据，双向链表比单链表占用更多的存储空间。

##### 优点

- 支持双向遍历
- 在某些情况下的插入、删除操作比单链表高效
- 实际软件开发中，尽管费内存，但是双链表应用更加广泛（空间换时间）

### 4. 双向循环链表（Doubly Circular Linked List）

### 定义

双向循环链表是双向链表和循环链表的结合体：

- 双向链表**尾结点的后继指针 next 指向头结点**

- 双向链表**头结点的前驱指针 prev 指向尾结点**。

<img src="../images/doubly-circular-linked-list-definition.png" alt="img" style="zoom:45%;float:left;" />

## 链表与数组的对比

数组与链表是两种截然不同的内存组织方式。正是因为内存存储的区别，所以他们的插入、删除、随机访问操作的时间复杂度正好相反。

|                      | 数组 | 链表 |
| -------------------- | :--: | :--: |
| **插入与删除**       | O(n) | O(1) |
| **查询（随机访问）** | O(1) | O(n) |

### 数组

**数组的优点**：是简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，**所以访问效率更高**。

**数组的缺点**：**大小固定**，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致内存不足。而如果声明的数组过小，则可能出现不够用的情况，需要再申请一个更大的内存空间，把原数组拷贝过去，操作比较耗时。

### 链表

**链表的优点**：链表本身没有大小的限制，支持动态扩容。

**链表的缺点**：链表的每个结点需要额外的空间去存储结点的指针，会消耗更多内存。对链表进行频繁的插入、删除操作，还会导致频繁的内存申请与释放，容易造成内存碎片。

## 常见链表代码的几个技巧

### 技巧一：理解指针或引用的含义

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，我们通过指针就能找到这个变量。

```c
p->next=p->next->next
```

p 结点的 next 指针存储了 p 结点的下下个结点的内存地址。

### 技巧二：警惕指针丢失和内存泄露

在插入结点时，一定要注意操作顺序。

### 技巧三：利用哨兵简化实现难度

单链表的插入操作：

```c
// 在单链表中的结点 p 后面插入一个新的结点
new_node->next = p->next;
p->next = new_node;

// 如果要向空链表中插入第一个结点
if (head == null) {
  head = new_node;
}
```

单链表的删除操作：

```c
// 删除节点 p 的后继结点
p->next = p->next->next;

// 如果是删除链表中的最后一个结点
if(p->next == null) {
  head = null;
}
```

针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。可以使用**哨兵**，来解决边界问题，其并不参与业务逻辑。

如果引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。把这种有哨兵结点的链表叫做**带头链表**。

### 技巧四：重点留意边界条件处理

经常用来检查链表代码是否正确的边界条件有这样几个：

- 链表为空
- 链表只包含一个结点
- 链表包含两个结点
- 代码逻辑在处理头结点和尾结点的时候能否正常工作

### 技巧五：举例画图，辅助思考

<img src="../images/sovle-linked-list-problems-skill-5.png" alt="img" style="zoom:50%;float:left;" />

## 常见的链表操作

1. 单链表反转 (LeetCode NO. 206)
2. 链表中环的检测 (LeetCode NO. 141)
3. 两个有序链表的合并 (LeetCode NO. 21)
4. 删除链表倒数第 n 个结点 (LeetCode NO. 19)
5. 求链表的中间结点 (LeetCode NO. 876)